
\section{Введение}
\label{sec:intro}
\subsection{Проблемы микросервисной архитектуры}
%Исторически, приложения проектировались в соответствии с монолитной архитектурой, но постепенно стали появляться приложения реализованные в соответствии с  микросервисной архитектурой. Обычно этот переход сопровождает вынос части логики из монолита в межсервисное взаимодействие. В связи с этим усложнялся програмный код - в монолитной архитектуре разные части приложения могли просто вызывать функции из других частей, но при переходе на новую архитектуру так делать уже нельзя, ведь эти разные компоненты могут даже находиться на разных физических хостах и приходится уже общаться через сеть, что вызывает дополнительные нагрузки на разработку и эффективность работы программы.
Компании вс ечаще задумываются над переносом своего монолитного приложения на микросервисную архитектуру. Также многие компании используют облака для развертывания своих микросервисов. Как известно, монолитные приложения сложны при програмировании и у них длинный релизный цикл.

В то время как микросервисная архитектура способствует ускорению релизного цикла и ускорению разработки, оно также добавляет некие новые сложности, например такие, как описанные ниже.
\begin{itemize}
	\item Безопасность -- в отличие от монолитного приложения, где одни функции просто вызывают другие, в микросервисной архитектуре это обычно трансформируется в запросы по сети из одного сервиса в другой с необходимостью отслеживать всю эту коммуникацию.
	\item Отказоустойчивость -- значительно увеличивается граф зависимостей между сервисами, что ведет к замедлению работы программы из-за большого количества последовательных запросов по сети и также повышает вероятность каскадного отказа сервисов из-за отказа всего лишь одного.
	\item Правила межсервисного взаимодействия -- некоторые сервисы могут становиться узкими местами при выполнениях функций других сервисов. Необходимо настраивать квоты и определять политики, котороые описывают какие сервисы к каким могут совершать вызовы и как много таких вызовов может совершаться.
	\item Наблюдаемость -- по сравнению с монолитными приложениями, где достаточно файлов лога, в микросервисной архитектуре один полноценный запрос может проходить через несколько приложений. Получается, что ошибка может возникнуть в любом месте этой цепочки и разработчикам необходимо не только хранить файлы лога, но и иметь возможность следить за сетевыми показателями сервисов, процессом прохождения через цепочку сервисов отдельного запроса и за топологией всего кластера.
\end{itemize}

\subsection{Service Mesh}
Service Mesh -- отдельный уровень в микросервисной архитектуре, который абстрагирует в себе межсетевое взаимодействие отдельных сервисов и позволяет единообразным образом, независимо от кода отдельных приложений, решать следующие проблемы:

\begin{itemize}
	\item Обеспечение безопасности -- традиционная сетевая безопасность основана на обеспечении надежного периметра для предотвращения доступа злоумышленника внутрь. Service Mesh же, в свою очередь, предоставляет идентификатор для каждого сервиса и уже по этим идентификаторам происходит аутентификация и авторизация, обеспечивается контроль того,  как различные сервисы могут общаться между собой. Также Service Mesh позволяет разработчикам использовать различные протоколы, например mTLS для обеспечения зашифрованного трафика между сервисами и предотвращения атак men-in-the-middle.
	\item Наблюдаемость -- из-за особенностей реализации Service Mesh, весь сетевой трафик внутри сети протекает через него. Далее, Service Mesh генерирует необходимые типы телеметрии: метрики, трейсы, логи доступов и складывает в хранилище.
	\item Балансировка нагрузки -- обычно у каждого сервиса запущено несколько инстансов и общая нагрузка распределяется между ними. В качестве способа балансирования часто используют алгоритм round-robin(равномерное распределение запросов к каждому инстансу) или взвешенный round-robin(то же самое, что и round-robin, но у каждого инстанса есть свой вес) или же случайный что не учитывает, например, того, что разные запросы могут быть разной сложности. Service Mesh же, имея у себя все необходимые метрики, позволяет использовать более умные алгоритмы балансировки нагрузки.
	\item Поиск сервисов -- часто у сервисов меняется количество инстансов или сами инстансы меняют физические хосты. Service Mesh может обрабатывать эти ситуации и самостоятельно перенаправлять запросы к живым, в текущий момент, инстансам используя определенное ранее правило балансировки.
\end{itemize}

Обычно архитектура Service Mesh делится на 2 концептуальные части:
\begin{itemize}
	\item Data plane -- обычно это набор проксей, которые перехватывают весь входящий и исходящий трафик конкретного сервиса и перенаправляет его в соответствии со своей конфигурацией. Также эти прокси собирают телеметрию и отправляют ее в Service Mesh.
	\item Control plane -- набор приложений в Service Mesh, которые отслеживают состояния всех сервисов и в соответствии с этим переконфигурируют прокси.
\end{itemize}

\subsection{Существующие решения}

Рассмотрим самые популярные реализации Service Mesh.

\begin{itemize}
	\item Istio -- open source решение от Google, которое в качестве прокси использует Envoy. Istio имеет широкие возможности конфигурации, но потребляет достаточно большое количество ресурсов. Изначально Istio спроектировано для работы с кластером Kubernetes, но его также можно использовать и с пользовательской системой развертывания. В итоге, если суметь сконфигурировать Istio, то получиться достаточно универсальный инструмент, который решает перечисленные выше проблемы, но тут ощущается недостаток документации и статей о том, как сделать что-то.
	\item Linkerd -- open source решение, которое в качестве Data Plane использует собственную легковесную прокси, из-за чего накладные расходы от Service Mesh в разы меньше. Linkerd предоставляет меньше возможностей конфигурации, что делает эту самую конфигурацию более простой.
\end{itemize}

Получается, что Linkerd подходит для тех, кому нужен просто быстрый Service mesh который практически не надо конфигурировать, в случае же когда от Service Mesh требуются специфические настройки, то следует использовать Istio.

Мы же, в свою очередь, хотим настроить Service Mesh для 1С Облака, в котором имеется своя собственная система развертывания и где не используется Kubernetes. Из-за этого Linkerd нам точно не подходит, потому что он не используется вне Kubernetes. Istio нам также не подходит так как, хоть его и можно использовать вне Kubernetes, но для этого не хватает документации.

В итоге мы пришли к тому, что нам необходимо разработать собственное решение данной задачи. Мы остановились на том, что на данный момент из всей функциональности Service Mesh нам необходимо реализовать только следующий набор:
\begin{itemize}
	\item Мониторинг
	\item Балансировка
	\item Автоматическое перенаправление запросов 
\end{itemize}

\subsection{Цель и задачи}

Целью работы является реализации компоненты Service Mesh, которая отвечает за переконфигурирование sidecar-proxy. В качестве прокси мы решили использовать Envoy так как он позволяет себя динамически переконфигурировать.
\begin{itemize}
	\item исследовать текущие решения и спроектировать архитектуру Service Mesh
	\item определить, какую прокси следует использовать в Data Plane
	\item реализовать набор инструментов для упрощения создания стартовых конфигураций прокси
	\item реализовать приложение Controller, которое ответственно за доставку новых конфигураций для этих прокси
	 \item протестировать приложение Controller и инструменты для изначального начального запуска прокси
\end{itemize}

В результате работы были получены следующие результаты:
\begin{itemize}
    \item создана архитектура Service Mesh
	\item выбран Envoy в качестве прокси для Data Plane
	\item написан bash-скрипт для создания начальной конфигурации Envoy
	\item реализовано приложение Controller
	\item реализовано отдельное приложение для тестирования приложения Controller и bash-скрипта
\end{itemize}
%(https://linkerd.io/2021/05/27/linkerd-vs-istio-benchmarks/?_gl=1*40ac7o*_ga*MTgzNzM2NTQ2My4xNjUyMjU3NDE3*_ga_TV358ZPK6D*MTY1MjQ0ODIyOS4zLjEuMTY1MjQ0ODIzMC4w#_ga=2.221305884.50908095.1652424877-1837365463.1652257417)
